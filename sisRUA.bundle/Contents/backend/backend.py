import osmnx as ox
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon
import os
import uuid

class UrbanProfiles:
    """Manages urban profiles for road width definitions."""
    PROFILES = {
        "PADRAO_URBANO": {
            "residential": 5.0,
            "tertiary": 8.0,
            "secondary": 10.0,
            "primary": 12.0,
            "motorway": 20.0,
            "footway": 2.0,
            "cycleway": 3.0,
            "service": 4.0,
            # Add other road types as needed
            "default": 6.0 # Default width if type is not specified
        },
        # Add other profiles as needed
    }

    @staticmethod
    def get_road_width(profile_name: str, highway_type: str) -> float:
        profile = UrbanProfiles.PROFILES.get(profile_name)
        if not profile:
            raise ValueError(f"Urban profile '{profile_name}' not found.")
        return profile.get(highway_type, profile["default"])

class UrbanAutoCAD:
    """Handles AutoCAD-related operations, like DXF generation."""

    @staticmethod
    def desenhar_dxf(latitude: float, longitude: float, radius: float, profile_name: str = "PADRAO_URBANO") -> str:
        """
        Generates a DXF file from OSM data based on given coordinates and radius,
        applying road widths from the specified urban profile.
        """
        graph = ox.graph_from_point((latitude, longitude), dist=radius, network_type="all")
        
        # Convert graph to GeoDataFrames
        nodes, edges = ox.graph_to_gdfs(graph)

        # Create a temporary directory for outputs
        temp_dir = "temp_dxf_outputs"
        os.makedirs(temp_dir, exist_ok=True)
        
        # Generate a unique DXF filename
        dxf_filename = f"urban_plan_{uuid.uuid4()}.dxf"
        dxf_filepath = os.path.join(temp_dir, dxf_filename)

        # Prepare to write to DXF using fiona and shapely
        # Fiona needs a schema for the shapefile. Let's define a simple one for lines.
        schema = {
            'geometry': 'LineString',
            'properties': {'name': 'str', 'highway': 'str', 'width': 'float'},
        }

        # DXF driver for Fiona is actually 'ESRI Shapefile' then converted or using specific DXF libraries.
        # For simplicity, let's output to a temporary GeoPackage and then convert or simulate DXF creation.
        # A direct DXF output with widths requires a more advanced library or manual DXF structure generation.
        # For this prototype, we'll store width as a property.

        # Filter out non-road edges if necessary, or process all
        road_edges = edges[(edges['highway'].notna())]
        
        geometries = []
        for _, row in road_edges.iterrows():
            highway_type = row['highway']
            if isinstance(highway_type, list):
                highway_type = highway_type[0] # Take the first type if multiple are listed
            
            width = UrbanProfiles.get_road_width(profile_name, highway_type)
            
            # For visualization, we could buffer the lines to create polygons
            # But for DXF import as polylines, we'll just use the original line geometry
            # The width information will be metadata for now.
            if row['geometry'].geom_type == 'LineString':
                geometries.append({
                    'geometry': row['geometry'],
                    'properties': {
                        'name': row.get('name', 'Unnamed Road'),
                        'highway': highway_type,
                        'width': width
                    }
                })
            elif row['geometry'].geom_type == 'MultiLineString':
                for line in row['geometry'].geoms:
                    geometries.append({
                        'geometry': line,
                        'properties': {
                            'name': row.get('name', 'Unnamed Road'),
                            'highway': highway_type,
                            'width': width
                        }
                    })

        # This part simulates generating a DXF. In a real application, you'd use a library
        # like ezdxf or similar to create the DXF entities with specific properties (like width).
        # For now, we'll create a dummy file and assume the C# side will handle interpretation.
        with open(dxf_filepath, "w") as f:
            f.write(f"DXF_FILE_HEADER\n")
            f.write(f"Generated by sisRUA for {latitude}, {longitude} with radius {radius}\n")
            f.write(f"Profile: {profile_name}\n")
            for geom_data in geometries:
                geom = geom_data['geometry']
                props = geom_data['properties']
                f.write(f"LINE:{geom.wkt}, Highway:{props['highway']}, Width:{props['width']}\n")
            f.write(f"DXF_FILE_END\n")

        print(f"Generated dummy DXF at: {dxf_filepath}")
        return dxf_filepath

# Example Usage (for testing purposes)
if __name__ == "__main__":
    test_lat, test_lon, test_rad = -23.550520, -46.633308, 500 # SÃ£o Paulo coordinates
    dxf_path = UrbanAutoCAD.desenhar_dxf(test_lat, test_lon, test_rad, "PADRAO_URBANO")
    print(f"Test DXF generated at: {dxf_path}")
